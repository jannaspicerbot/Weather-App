# Weather App — Technical Specification
Date: 2026-01-02
Based on finalized PRD and current implementation for jannaspicerbot/Weather-App

Purpose
- Document the implemented architecture: local-first Python + TypeScript app that ingests Ambient Weather data at native cadence, supports resumable backfill with checkpoints, stores data in DuckDB with 50-year full-resolution retention, exposes an interactive web dashboard (React + TypeScript + Recharts), provides FastAPI backend with OpenAPI schema, supports CLI operations (Click framework), stores secrets in .env file, and optionally runs via Docker Compose.
- Serve as the authoritative reference for the current system architecture and future enhancements.

Contents
1. High-level architecture
2. Technology stack
3. Project layout
4. Database schema and retention
5. Data ingestion and backfill
6. FastAPI backend endpoints
7. React frontend application
8. CLI commands
9. Configuration and secrets
10. Deployment options
11. Observability and health checks
12. Testing strategy and CI/CD
13. Backup and restore
14. Future enhancements

---

## 1. High-level architecture

**Components:**
- **CLI (Click)**: Commands for init-db, fetch, backfill, export, info
- **API Client**: Ambient Weather API wrapper with retry/backoff logic
- **FastAPI Backend**: REST API with OpenAPI schema, serves weather data and health endpoints
- **React Frontend**: TypeScript + Vite + Recharts for interactive visualizations
- **DuckDB Database**: Embedded analytical database with columnar storage and compression
- **Docker Compose**: Multi-container orchestration for one-command deployment

**Data Flow:**
1. CLI `fetch` command → Ambient Weather API → Parse response → Upsert to DuckDB
2. CLI `backfill` command → Chunked API requests with checkpoints → Batch insert to DuckDB
3. React frontend → Fetch from FastAPI → Query DuckDB → Return JSON → Render Recharts
4. CLI `export` command → Query DuckDB → Write CSV file

**Deployment Options:**
- Native: Python venv + npm (development)
- Docker Compose: Backend + Frontend in containers (recommended for users)

## 2. Technology stack

### Backend
- **Python 3.11+**: Modern type hints, improved performance
- **FastAPI**: High-performance async framework with automatic OpenAPI schema
- **DuckDB**: Embedded analytical database (10-100x faster than SQLite for time-series)
- **Pydantic**: Data validation and serialization with type safety
- **Click**: CLI framework for command-line tools
- **Requests**: HTTP client for Ambient Weather API
- **Python-dotenv**: .env file support

### Frontend
- **TypeScript**: Type-safe JavaScript for compile-time error detection
- **React 18**: UI framework with hooks and modern patterns
- **Vite**: Fast build tool and dev server
- **Recharts**: React charting library built on D3
- **TailwindCSS**: Utility-first CSS framework
- **React Query**: Server state management and caching

### DevOps
- **Docker & Docker Compose**: Containerization and orchestration
- **GitHub Actions**: CI/CD for tests, linting, builds
- **pytest**: Python testing framework
- **Vitest**: Fast TypeScript/JavaScript testing
- **black, mypy, isort**: Python code quality tools
- **ESLint, Prettier**: TypeScript code quality tools

## 3. Project layout

```
weather-app/
├── weather_app/                  # Python package
│   ├── __init__.py
│   ├── api/                      # FastAPI application
│   │   ├── __init__.py
│   │   ├── main.py              # FastAPI app instance
│   │   ├── routes.py            # API endpoints
│   │   └── models.py            # Pydantic models
│   ├── cli/                      # Click CLI
│   │   ├── __init__.py
│   │   └── cli.py               # CLI commands
│   ├── database/                 # DuckDB layer
│   │   ├── __init__.py
│   │   ├── connection.py        # Database connection
│   │   ├── schema.py            # Table schemas
│   │   └── repository.py        # Data access (pragmatic pattern)
│   ├── services/                 # Business logic
│   │   ├── __init__.py
│   │   ├── ambient_client.py    # API client
│   │   ├── fetcher.py           # Fetch service
│   │   └── backfill.py          # Backfill service
│   └── config.py                 # Configuration
├── web/                          # React frontend
│   ├── src/
│   │   ├── components/          # React components
│   │   ├── hooks/               # Custom React hooks
│   │   ├── services/            # API client
│   │   ├── types/               # TypeScript types
│   │   ├── App.tsx
│   │   └── main.tsx
│   ├── package.json
│   ├── tsconfig.json
│   └── vite.config.ts
├── tests/                        # Python tests
│   ├── test_api.py
│   ├── test_cli.py
│   └── test_database.py
├── docs/                         # Documentation
│   ├── technical/
│   └── user/
├── docker-compose.yml           # Docker orchestration
├── Dockerfile.backend           # Backend container
├── Dockerfile.frontend          # Frontend container
├── pyproject.toml               # Python package config
├── requirements.txt             # Python dependencies
├── .env.example                 # Environment template
└── .github/workflows/           # CI/CD
    └── ci.yml
```

## 4. Database schema and retention

**DuckDB Schema (weather_data table):**

```sql
CREATE TABLE weather_data (
    timestamp TIMESTAMP PRIMARY KEY,
    temperature DOUBLE,           -- Fahrenheit
    feels_like DOUBLE,             -- Fahrenheit
    humidity DOUBLE,               -- Percentage
    dew_point DOUBLE,              -- Fahrenheit
    wind_speed DOUBLE,             -- mph
    wind_gust DOUBLE,              -- mph
    wind_direction INTEGER,        -- Degrees
    pressure DOUBLE,               -- inHg
    precipitation_rate DOUBLE,     -- in/hr
    precipitation_total DOUBLE,    -- inches
    solar_radiation DOUBLE,        -- W/m²
    uv_index INTEGER,
    battery_ok BOOLEAN
);

CREATE INDEX idx_timestamp ON weather_data(timestamp);
```

**Retention Policy:**
- **50 years full-resolution** (no aggregation)
- Storage estimate: 5.2M readings @ ~1KB = ~500MB-1GB with DuckDB compression
- Philosophy: "Storage is cheap" - no need for complex aggregation pipelines
- Columnar storage + compression makes full-resolution feasible

**Data Integrity:**
- PRIMARY KEY on timestamp ensures no duplicates
- Upsert pattern: `INSERT OR REPLACE` for idempotent writes
- No foreign keys (single table design for simplicity)

## 5. Data ingestion and backfill

### Fetch Command (`weather-app fetch`)

**Behavior:**
1. Read latest timestamp from DuckDB `weather_data` table
2. If no records exist, fetch last 24 hours
3. Call Ambient Weather API: `GET /v1/devices/{macAddress}?limit=288`
4. Parse response and transform to internal schema
5. Upsert to DuckDB using `INSERT OR REPLACE`
6. Log: fetched count, inserted count, duplicates skipped

**Error Handling:**
- Exponential backoff: 1s, 2s, 4s, 8s (max 5 retries)
- Respect HTTP 429 (rate limit) and Retry-After headers
- Log all API errors with request/response details

### Backfill Command (`weather-app backfill`)

**Inputs:**
- `--start DATE`: Start date (YYYY-MM-DD)
- `--end DATE`: End date (YYYY-MM-DD)
- `--checkpoint FILE`: Optional checkpoint file path

**Behavior:**
1. Break date range into daily chunks
2. For each chunk:
   - Call Ambient Weather API with 288 records/day limit
   - Parse and batch insert to DuckDB (1000 records/batch)
   - Write checkpoint: `{"last_processed": "2024-05-12", "total_inserted": 51840}`
3. On restart, read checkpoint and resume from last_processed + 1 day
4. Final report: total days processed, total records inserted, errors

**Checkpoint Format (JSON):**
```json
{
  "start_date": "2024-01-01",
  "end_date": "2024-12-31",
  "last_processed": "2024-05-12",
  "total_inserted": 51840,
  "errors": []
}
```

**Idempotency:**
- PRIMARY KEY constraint on timestamp prevents duplicates
- `INSERT OR REPLACE` ensures safe re-runs
- Backfill can be interrupted and resumed without data loss

## 6. FastAPI backend endpoints

**Base URL:** `http://localhost:8000/api`

### Health Endpoint
```
GET /api/health
Response: {
  "status": "ok",
  "database": "connected",
  "total_records": 125432,
  "latest_reading": "2024-12-31T23:55:00Z",
  "oldest_reading": "2024-01-01T00:00:00Z"
}
```

### Weather Data Endpoints
```
GET /api/weather/latest
Returns: WeatherReading (most recent record)

GET /api/weather/range?start=TIMESTAMP&end=TIMESTAMP
Returns: List[WeatherReading] (paginated, max 10000 records)

GET /api/weather/stats?period=24h|7d|30d|1y
Returns: WeatherStats (aggregated statistics)
```

### Export Endpoint
```
GET /api/export?start=TIMESTAMP&end=TIMESTAMP&format=csv
Returns: CSV file download (Content-Type: text/csv)
```

**Pydantic Models:**
```python
class WeatherReading(BaseModel):
    timestamp: datetime
    temperature: float
    feels_like: float | None
    humidity: float | None
    # ... other fields

class WeatherStats(BaseModel):
    period: str
    avg_temperature: float
    min_temperature: float
    max_temperature: float
    total_precipitation: float
```

**CORS:** Enabled for http://localhost:3000 (Vite dev server)

## 7. React frontend application

**Tech Stack:**
- React 18 + TypeScript
- Vite (build tool + dev server)
- Recharts (charting library)
- TailwindCSS (styling)
- React Query (data fetching + caching)

**Components:**
- `WeatherDashboard`: Main container component
- `TemperatureChart`: Line chart for temperature over time
- `HumidityChart`: Area chart for humidity
- `WindChart`: Combined speed/direction visualization
- `PrecipitationChart`: Bar chart for rainfall
- `CurrentConditions`: Latest reading summary card
- `DateRangePicker`: Date range selector for historical data

**Features:**
- Real-time data updates (polling every 5 minutes)
- Interactive charts with zoom/pan
- Responsive design (mobile, tablet, desktop)
- Loading states and error handling
- CSV export button

**API Client (TypeScript):**
```typescript
class WeatherAPI {
  async getLatest(): Promise<WeatherReading>
  async getRange(start: Date, end: Date): Promise<WeatherReading[]>
  async getStats(period: string): Promise<WeatherStats>
  async exportCSV(start: Date, end: Date): Promise<Blob>
}
```

## 8. CLI commands

**Installation:**
```bash
pip install -e .
# or
pip install weather-app
```

**Commands:**

### Database Initialization
```bash
weather-app init-db
# Creates DuckDB database with schema at configured path
```

### Fetch Latest Data
```bash
weather-app fetch
# Fetches latest readings from Ambient Weather API
# Uses configuration from .env file
```

### Backfill Historical Data
```bash
weather-app backfill --start 2024-01-01 --end 2024-12-31
# Optional: --checkpoint backfill.json (resume support)
```

### Export to CSV
```bash
weather-app export --start 2024-01-01 --end 2024-12-31 --output data.csv
```

### Database Info
```bash
weather-app info
# Shows: total records, date range, database size, path
```

**Future Commands:**
- `weather-app serve` - Run FastAPI server
- `weather-app test-connection` - Test Ambient Weather API connection

## 9. Configuration and secrets

**Environment Variables (.env file):**
```bash
# Required
AMBIENT_API_KEY=your_api_key_here
AMBIENT_APPLICATION_KEY=your_app_key_here
STATION_MAC_ADDRESS=00:11:22:33:44:55

# Optional
DATABASE_PATH=./weather.db          # Default: ./weather.db
LOG_LEVEL=INFO                       # Default: INFO
API_TIMEOUT=30                       # Default: 30 seconds
RETRY_MAX_ATTEMPTS=5                 # Default: 5
```

**.env.example (template in repository):**
```bash
AMBIENT_API_KEY=
AMBIENT_APPLICATION_KEY=
STATION_MAC_ADDRESS=
DATABASE_PATH=./weather.db
LOG_LEVEL=INFO
```

**Security:**
- .env file is .gitignored (never committed)
- Keys stored locally only (never transmitted to external services)
- File permissions: chmod 600 .env (recommended)
- Future: Web UI for key management with encrypted storage

## 10. Deployment options

### Docker Compose (Recommended for Users)

**One-command deployment:**
```bash
docker-compose up -d
```

**docker-compose.yml:**
```yaml
version: '3.8'
services:
  backend:
    build:
      context: .
      dockerfile: Dockerfile.backend
    ports:
      - "8000:8000"
    volumes:
      - ./data:/app/data
      - ./.env:/app/.env
    environment:
      - DATABASE_PATH=/app/data/weather.db

  frontend:
    build:
      context: ./web
      dockerfile: ../Dockerfile.frontend
    ports:
      - "3000:80"
    depends_on:
      - backend
```

**Access:** http://localhost:3000

### Native Python (Development)

**Backend:**
```bash
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate
pip install -r requirements.txt
uvicorn weather_app.api.main:app --reload --port 8000
```

**Frontend:**
```bash
cd web
npm install
npm run dev  # Vite dev server on port 3000
```

### Scheduling (Optional)

**Cron (Linux/macOS):**
```bash
# Fetch every 5 minutes
*/5 * * * * /path/to/venv/bin/weather-app fetch >> /var/log/weather.log 2>&1
```

**Task Scheduler (Windows):**
- Create scheduled task to run `weather-app fetch` every 5 minutes
- Future: Built-in APScheduler for automated fetching

## 11. Observability and health checks

**Logging:**
- Python `logging` module with INFO/DEBUG levels
- Log format: `%(asctime)s - %(name)s - %(levelname)s - %(message)s`
- Log location: stdout (Docker) or `./logs/weather-app.log` (native)
- Future: Structured JSON logging with correlation IDs

**Health Endpoint:**
```
GET /api/health
Response: {
  "status": "ok",
  "database": "connected",
  "total_records": 125432,
  "latest_reading": "2024-12-31T23:55:00Z",
  "database_size_mb": 45.2
}
```

**Future Monitoring:**
- Prometheus /metrics endpoint
- Grafana dashboard templates
- Sentry error tracking (free tier)

## 12. Testing strategy and CI/CD

**Python Tests (pytest):**
```bash
pytest tests/
# Unit tests: API client, database, CLI commands
# Integration tests: End-to-end data flow with test DuckDB
```

**Frontend Tests (Vitest):**
```bash
cd web && npm test
# Component tests, API client tests, type checking
```

**CI Pipeline (GitHub Actions):**
```yaml
name: CI
on: [push, pull_request]
jobs:
  backend-tests:
    - black --check
    - mypy weather_app/
    - pytest tests/

  frontend-tests:
    - npm run lint
    - npm run type-check
    - npm test

  docker-build:
    - docker-compose build
    - docker-compose up -d
    - curl http://localhost:8000/api/health
```

**Coverage Target:** 70% minimum

## 13. Backup and restore

**Backup (Manual):**
```bash
# DuckDB is a single file - just copy it
cp ./data/weather.db ./backups/weather_$(date +%Y%m%d).db

# Optional: compress
gzip ./backups/weather_$(date +%Y%m%d).db
```

**Restore:**
```bash
cp ./backups/weather_20241231.db ./data/weather.db
```

**Automated Backup Script:**
```bash
#!/bin/bash
# backup_weather.sh
BACKUP_DIR=~/weather-backups
mkdir -p $BACKUP_DIR
cp ./data/weather.db $BACKUP_DIR/weather_$(date +%Y%m%d_%H%M%S).db
find $BACKUP_DIR -name "weather_*.db" -mtime +30 -delete  # Keep 30 days
```

**Future:** Automated backup to NAS/S3 with retention policies

## 14. Future enhancements

**Phase 3 Planned Features:**
- Multi-station support (2-5 stations)
- Built-in scheduler (APScheduler) - no cron needed
- Web UI configuration interface
- User authentication for web dashboard
- Real-time WebSocket updates
- Mobile app (React Native)
- Additional export formats (JSON, Parquet)
- Weather alerts and notifications
- Historical data analysis tools
- Machine learning forecasting

**Migration Path:**
- DuckDB → Parquet export for InfluxDB/TimescaleDB migration
- CSV export for compatibility with any platform

---

## Implementation Status

**Phase 1 (Completed):** ✅
- CLI with Click framework
- DuckDB database integration
- Ambient Weather API client
- Basic fetch and backfill commands

**Phase 2 (Completed):** ✅
- FastAPI backend with OpenAPI schema
- React + TypeScript frontend
- Recharts visualizations
- Docker Compose deployment
- End-to-end type safety

**Phase 3 (Planned):**
- Multi-station support
- Built-in scheduler (APScheduler)
- Web UI configuration
- User authentication
- Real-time updates

---

## Document Changelog

- 2026-01-02: Initial specification based on SQLite/Flask architecture
- 2026-01-02: Updated to reflect implemented DuckDB/FastAPI/React architecture with 50-year full-resolution retention
